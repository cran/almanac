<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Adjusting and Shifting Dates</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Adjusting and Shifting Dates</h1>



<p>If you have read the introduction vignette, <code>vignette(&quot;almanac&quot;)</code>, then you’ve seen rrules, rbundles, and the functions <code>alma_search()</code>, <code>alma_events()</code>, and <code>alma_in()</code>. Additionally included in almanac are a set of tools for <em>adjusting</em> and <em>shifting</em> dates. These functions are broken down as:</p>
<ul>
<li><p>Adjustment functions, such as <code>adj_following()</code> and <code>adj_nearest()</code></p></li>
<li><p>Adjusted rschedules</p></li>
<li><p><code>alma_step()</code></p></li>
<li><p><code>stepper()</code></p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(almanac)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(lubridate, <span class="dt">warn.conflicts =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<div id="adjusting" class="section level2">
<h2>Adjusting</h2>
<p>“Adjusting” a date defines the behavior of what happens if a date lands on an event in a rschedule’s event set. For example, if you have a date that is currently on Christmas, you could adjust forward to the next non-event date, adjust backwards to the previous non-event date, or adjust to the nearest non-event date. The logic of how to perform these adjustments is encoded into the following adjustment functions:</p>
<ul>
<li><p><code>adj_following()</code></p>
<p>Choose the first non-event date after <code>x</code>.</p></li>
<li><p><code>adj_preceding()</code></p>
<p>Choose the first non-event date before <code>x</code>.</p></li>
<li><p><code>adj_modified_following()</code></p>
<p>Choose the first non-event date after <code>x</code>, unless it falls in a different month, in which case the first non-event date before <code>x</code> is chosen instead.</p></li>
<li><p><code>adj_modified_preceding()</code></p>
<p>Choose the first non-event date before <code>x</code>, unless it falls in a different month, in which case the first non-event date after <code>x</code> is chosen instead.</p></li>
<li><p><code>adj_nearest()</code></p>
<p>Choose the nearest non-event date to <code>x</code>. If the closest preceding and following non-event dates are equally far away, the following non-event date is chosen.</p></li>
<li><p><code>adj_none()</code></p>
<p>Performs no adjustment and returns <code>x</code> unchanged.</p></li>
</ul>
<p>To use an adjustment function, you’ll need an rschedule that contains the event set you are interested in adjusting around. Then provide that, along with the dates you are interested in adjusting, to an <code>adj_*()</code> function.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>on_christmas &lt;-<span class="st"> </span><span class="kw">yearly</span>() <span class="op">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="st">  </span><span class="kw">recur_on_mday</span>(<span class="dv">25</span>) <span class="op">%&gt;%</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="st">  </span><span class="kw">recur_on_ymonth</span>(<span class="st">&quot;Dec&quot;</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>x &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="st">&quot;2019-12-24&quot;</span>, <span class="st">&quot;2019-12-25&quot;</span>))</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">adj_following</span>(x, on_christmas)</span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">#&gt; [1] &quot;2019-12-24&quot; &quot;2019-12-26&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">adj_preceding</span>(x, on_christmas)</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">#&gt; [1] &quot;2019-12-24&quot; &quot;2019-12-24&quot;</span></span></code></pre></div>
<p>The <code>adj_nearest()</code> function is particularly useful when you have a date on a weekend and want to roll it back to Friday if it falls on Saturday but roll it forward to Monday if it falls on Sunday.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Saturday / Sunday</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>x &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="st">&quot;2019-12-21&quot;</span>, <span class="st">&quot;2019-12-22&quot;</span>))</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>on_weekends &lt;-<span class="st"> </span><span class="kw">weekly</span>() <span class="op">%&gt;%</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="st">  </span><span class="kw">recur_on_weekends</span>()</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co"># Roll Saturday backwards and Sunday forwards</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">adj_nearest</span>(x, on_weekends)</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">#&gt; [1] &quot;2019-12-20&quot; &quot;2019-12-23&quot;</span></span></code></pre></div>
</div>
<div id="adjusted-rschedules" class="section level2">
<h2>Adjusted rschedules</h2>
<p>In the introduction vignette, you were introduced to a number of different rschedules. As a reminder, an rschedule is just a general term for an rrule or an rbundle. There is actually a third type of rschedule in almanac, called radjusted, which is useful when combined with the adjustment functions.</p>
<p>To motivate it, imagine your company deems Christmas to be a holiday. Whenever Christmas rolls around on the 25th of December, you get that day off. But what happens when Christmas falls on a Saturday? What about Sunday? Most corporations will <em>observe</em> a holiday that falls on the weekend on the nearest working day instead of on the weekend date that it actually occurred on.</p>
<p>In almanac, it seems like this would pose a problem. You can create rrules for Christmas and for weekends, but an rbundle like runion, rintersect, or rsetdiff would perform some kind of set operation on them. What you really need is a way to say: recur on the dates defined by this rschedule, <em>unless</em> it intersects with this second rschedule. In those cases, apply an <em>adjustment</em> to the intersected dates to create valid dates. This is the job of radjusted.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>on_adjusted_christmas &lt;-<span class="st"> </span><span class="kw">radjusted</span>(</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="dt">rschedule =</span> on_christmas, </span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="dt">adjust_on =</span> on_weekends,</span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="dt">adjustment =</span> adj_nearest</span>
<span id="cb4-5"><a href="#cb4-5"></a>)</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>on_adjusted_christmas</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">#&gt; &lt;radjusted&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">#&gt; </span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">#&gt; Adjust:</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">#&gt; &lt;rrule[yearly / 1900-01-01 / 2100-01-01]&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">#&gt; - ymonth: Dec</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">#&gt; - mday: 25</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">#&gt; </span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">#&gt; Adjust on:</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co">#&gt; &lt;rrule[weekly / 1900-01-01 / 2100-01-01]&gt;</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="co">#&gt; - wday: Sat, Sun</span></span></code></pre></div>
<p>This is just another rschedule, so it can be used with all of the other <code>alma_*()</code> functions we’ve seen so far. For example, we can confirm that Christmas dates that fall on the weekend are adjusted appropriately by searching for a few of them.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Note 2004-12-24, which was rolled back from 2004-12-25, a Saturday.</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co"># Note 2005-12-26, which was rolled forward from 2005-12-25, a Sunday.</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">alma_search</span>(<span class="st">&quot;2002-01-01&quot;</span>, <span class="st">&quot;2008-01-01&quot;</span>, on_adjusted_christmas)</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">#&gt; [1] &quot;2002-12-25&quot; &quot;2003-12-25&quot; &quot;2004-12-24&quot; &quot;2005-12-26&quot; &quot;2006-12-25&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">#&gt; [6] &quot;2007-12-25&quot;</span></span></code></pre></div>
</div>
<div id="stepping" class="section level2">
<h2>Stepping</h2>
<p><code>alma_step()</code> allows you to take an existing vector of dates and shift it by a number of days, “stepping over” any events in the event set defined by an rschedule. This is generally useful for shifting by “N business days”, where the logic for a business day is encapsulated in the rschedule.</p>
<p>You can think of <code>alma_step()</code> as a way to replace lubridate’s <code>x + days(5)</code> with <code>x + business_days(5)</code> where <code>business_days()</code> is specific to your company’s holiday calendar.</p>
<p>In the following example, we shift a Thursday and Friday by 1 working day. Notice that Friday is shifted forward to Monday.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># A Thursday / Friday pair</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>x &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="st">&quot;2019-12-19&quot;</span>, <span class="st">&quot;2019-12-20&quot;</span>))</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co"># Shift by 1 working day, stepping over weekends</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>step &lt;-<span class="st"> </span><span class="kw">alma_step</span>(x, <span class="dt">n =</span> <span class="dv">1</span>, <span class="dt">rschedule =</span> on_weekends)</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">data.frame</span>(</span>
<span id="cb6-8"><a href="#cb6-8"></a>  <span class="dt">x =</span> x,</span>
<span id="cb6-9"><a href="#cb6-9"></a>  <span class="dt">x_wday =</span> <span class="kw">wday</span>(x, <span class="dt">label =</span> <span class="ot">TRUE</span>),</span>
<span id="cb6-10"><a href="#cb6-10"></a>  <span class="dt">step =</span> step,</span>
<span id="cb6-11"><a href="#cb6-11"></a>  <span class="dt">step_wday =</span> <span class="kw">wday</span>(step, <span class="dt">label =</span> <span class="ot">TRUE</span>)</span>
<span id="cb6-12"><a href="#cb6-12"></a>)</span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">#&gt;            x x_wday       step step_wday</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">#&gt; 1 2019-12-19    Thu 2019-12-20       Fri</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">#&gt; 2 2019-12-20    Fri 2019-12-23       Mon</span></span></code></pre></div>
<p>Internally, <code>n</code> is applied 1 day at a time. <code>adj_following()</code> is called after each 1 day shift if <code>n</code> is positive, otherwise <code>adj_preceding()</code> is called.</p>
<p>To break this down, we’ll analyze the Friday.</p>
<ul>
<li><p>Start on <code>2019-12-20</code>, a Friday.</p></li>
<li><p>Step forward 1 day, to <code>2019-12-21</code>, a Saturday.</p></li>
<li><p>Apply <code>adj_following()</code>, landing us on Monday, <code>2019-12-23</code>.</p></li>
</ul>
<p>You can shift backwards with a negative <code>n</code>. It’s also fully vectorized, and you can use different signs of <code>n</code> in the same call. For an example, let’s consider what happens if you start on a non-event date. Here, we start on a Saturday and Sunday, and apply a +1 and -1 day shift to them, respectively.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># A Saturday / Sunday pair</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>x &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="st">&quot;2019-12-21&quot;</span>, <span class="st">&quot;2019-12-22&quot;</span>))</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>step &lt;-<span class="st"> </span><span class="kw">alma_step</span>(x, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">-1</span>), on_weekends)</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">data.frame</span>(</span>
<span id="cb7-7"><a href="#cb7-7"></a>  <span class="dt">x =</span> x,</span>
<span id="cb7-8"><a href="#cb7-8"></a>  <span class="dt">x_wday =</span> <span class="kw">wday</span>(x, <span class="dt">label =</span> <span class="ot">TRUE</span>),</span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="dt">step =</span> step,</span>
<span id="cb7-10"><a href="#cb7-10"></a>  <span class="dt">step_wday =</span> <span class="kw">wday</span>(step, <span class="dt">label =</span> <span class="ot">TRUE</span>)</span>
<span id="cb7-11"><a href="#cb7-11"></a>)</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">#&gt;            x x_wday       step step_wday</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="co">#&gt; 1 2019-12-21    Sat 2019-12-23       Mon</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="co">#&gt; 2 2019-12-22    Sun 2019-12-20       Fri</span></span></code></pre></div>
<p>For Saturday, we apply the 1 day shift, landing on Sunday, and then call <code>adj_following()</code>, landing on Monday.</p>
<p>For Sunday, we apply the -1 day shift, landing on Saturday, and then call <code>adj_preceding()</code>, landing on Friday.</p>
</div>
<div id="steppers" class="section level2">
<h2>Steppers</h2>
<p><code>alma_step()</code> is nice, but it would be really nice to have something like lubridate’s <code>x + days(5)</code> syntax, but relative to an rschedule. Due to some issues with how R’s S3 dispatch system works with <code>+</code>, this isn’t exactly replicable with almanac, but you can get close (lubridate uses R’s S4 object oriented system to get it to work, but I don’t want to go there).</p>
<p>First off, you need an object the holds information about how to shift relative to an rschedule. You can create one of these with <code>stepper()</code>. The only thing you give <code>stepper()</code> is the rschedule to step relative to. It returns a function of 1 argument, <code>n</code>, which you’ll call with the desired number of days to shift. The resulting object can be added to or subtracted from your vector of dates. It sounds a little complicated, but hopefully things will clear up with an example. Let’s reproduce the last example from the previous section:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>working_day &lt;-<span class="st"> </span><span class="kw">stepper</span>(on_weekends)</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>x <span class="op">%s+%</span><span class="st"> </span><span class="kw">working_day</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">-1</span>))</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">#&gt; [1] &quot;2019-12-23&quot; &quot;2019-12-20&quot;</span></span></code></pre></div>
<p>Notice the usage of <code>%s+%</code>. This replaces <code>+</code>, and allows you to step forward. There is also a <code>%s-%</code> for stepping backwards.</p>
<p>The nice thing about <code>working_day</code> is that you can continue to use it on other date vectors.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># A Wednesday</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>wednesday &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;2019-12-18&quot;</span>)</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co"># Returns Thursday, Friday, Monday</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>wednesday <span class="op">%s+%</span><span class="st"> </span><span class="kw">working_day</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co">#&gt; [1] &quot;2019-12-19&quot; &quot;2019-12-20&quot; &quot;2019-12-23&quot;</span></span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
